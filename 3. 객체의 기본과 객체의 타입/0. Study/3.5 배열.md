# 3. 객체의 기본과 객체의 타입

- [3. 객체의 기본과 객체의 타입](#3-객체의-기본과-객체의-타입)
  - [3.5 배열](#35-배열)
    - [3.5.1 배열 리터럴로 배열 만들기](#351-배열-리터럴로-배열-만들기)
    - [3.5.2 배열 요소에 접근하기](#352-배열-요소에-접근하기)
    - [3.5.3 배열 타입 기법](#353-배열-타입-기법)
    - [3.5.4 readonly 배열 타입](#354-readonly-배열-타입)
    - [3.5.5 배열의 기능 사용하기](#355-배열의-기능-사용하기)
    - [3.5.6 for-of 문 루프](#356-for-of-문-루프)
    - [3.5.7 튜플 타입](#357-튜플-타입)
    - [배열 요소 접근의 비밀스러운 위험성](#배열-요소-접근의-비밀스러운-위험성)

## 3.5 배열

배열 : 복수의 데이터를 모아 놓은 데이터 구조

- 배열은 객체의 일종

### 3.5.1 배열 리터럴로 배열 만들기

배열 리터럴 : 콤마로 구분 지은 몇 개의 식을 [ ] 안에 나열해서 만드는 식

요소 : 배열에 들어있는 각각의 값

```ts
const arr2 = [100, "문자열", false];
```

- 타입스크립트에서는 배열에 여러 종류의 타입을 동시에 넣을 수 있음

```ts
const arr1 = [4, 5, 6];
const arr2 = [1, 2, 3, ...arr1];

console.log(arr2); // [1, 2, 3, 4, 5, 6]이 출력된다
```

- 배열 리터럴 안에도 전개 구문을 사용할 수 있음
- 배열 리터럴의 전개 구문에는 배열 요소 대신 <u>...식</u>이 들어감
- <u>식</u>이 배열이라면 해당 배열의 모든 요소가 그 위치에 복사

### 3.5.2 배열 요소에 접근하기

인덱스 접근 : 배열의 요소에 접근하는 것 (배열 내의 각 요소는 이름을 갖지 않는 대신에 번호를 사용)

배열은 요소들이 순서대로 나열된 데이터 구조이며 맨 앞의 요소는 0번째가 됨

```ts
const arr = [0, 123, -456 * 100];
console.log(arr[0]); // 0이 출력된다
console.log(arr[1]); // 123이 출력된다
```

- [ ]를 이용해 배열의 요소를 얻을 수 있음
- 이는 배열이 객체의 일종이라는 증거
  - 객체에서는 [ ] 안에 프로퍼티명이 쓰이지만, 배열에서는 인덱스가 쓰임
  - 배열이 실제로 0이나 1과 같은 이름의 프로퍼티를 가진 객체이기 때문
  - arr[1] 구문으로 배열의 1번째 요소를 가져오는 것은 실제로 arr이라는 객체에서 1이라는 이름의 프로퍼티를 가져오는 것과 같음
- 프로퍼티명이 문자열임을 고려해보면 arr[1]이 arr["1"]과 같다고 생각할 수 있음
  - 타입 시스템이 없는 자바스크립트에서는 맞음
  - 하지만 타입스트립트에서 배열의 프로퍼티에 접근할 때 인덱스를 숫자로 지정하지 않으면 컴파일 에러가 남

```ts
const arr = [0, 123, -456 * 100];
// 여기는 OK
arr[1] = 5400;
// 여기는 에러
// 에러: Cannot assign to 'arr' because it is a constant.
arr = [1, 2, 345, 67];
```

- 배열이 const로 선언된 변수 arr에 들어있음에도 요소를 재할당할 수 있음
- 내용물이 바뀌어도 배열은 같은 객체 그대로이므로, 변수 arr에는 같은 객체가 계속 들어있는 셈
- 변수 arr을 재할당 하는 것은 const에 의해 금지됨

### 3.5.3 배열 타입 기법

배열의 타입은 <u>타입[ ]</u>이라는 특수한 구문으로 표현
[ ]의 앞에 있는 <u>타입</u>은 배열 요소의 타입

```ts
// 여기는 OK
const arr: number[] = [1, 10, 100];
// 여기는 컴파일 에러
// 에러: Type 'number' is not assignable to type 'string'.
const arr2: string[] = [123, -456];
```

- 변수 arr은 number[ ]라는 타입으로 표기, number 타입의 값을 요소로 가지는 배열
- 변수 arr2는 string[ ]이라는 타입으로 표기, number타입인 값이 대입되었기 때문에 에러

배열 타입은 `T[]` 대신에 `Array<T>`로 표현할 수 있음

이 Array는 내장된 제네릭 타입, 즉 타입스크립트에 의해 미리 준비된 제네릭 타입이며 하나의 타입 인수를 가짐

여기서 타입 인수는 배열 요소의 타입을 나타냄

`T[]`와 `Array<T>`의 의미에 큰 차이는 없음, 둘 중 어느 것을 사용하느냐는 취향 차이

```ts
// 간단한 타입의 배열
const arr1: boolean[] = [false, true];
// 복잡한 타입의 배열
const arr2: Array<{
  name: string;
}> = [{ name: "김철수씨" }, { name: "나영희씨" }, { name: "박영태씨" }];
```

- 간단한 타입의 배열은 `T[]`
- 복잡한 타입은 `Array<T>`으로 구분해서 사용할 수 있음

```ts
// number[] 타입
const arr = [1, 10, 100];
// (string | number | boolean)[] 타입
const arr2 = [100, "문자열", false];
```

- 이 예시는 변수에 타입 표기가 없음
- 이런 경우 타입 추론에 의해 변수의 타입이 구해짐
- 배열 리터럴에 대한 타입 추론에서는 배열 타입이 추론됨

### 3.5.4 readonly 배열 타입

읽기 전용 배열 타입 : 내용을 변경할 수 없는 배열 타입

`readonly T[]`와 같이 표기, `ReadonlyArray<T>`라는 다른 표기법도 있음

두 표기법의 관계는 `T[]`와 `Array<T>`의 관계와 유사

```ts
const arr: readonly number[] = [1, 10, 100];

// 에러: Index signature in type 'readonly number[]' only permits reading.
arr[1] = -500;
```

- 읽기 전용 배열 타입인 배열을 만들려면 타입 표기에 readonly라고 명시
- 변경할 필요가 없는 객체나 배열 타입에 적극적으로 readonly를 붙이면 소스 코드의 가독성이 향상

### 3.5.5 배열의 기능 사용하기

배열에는 다양한 조작을 위한 메서드가 존재

메서드는 객체의 프로퍼티에 들어있는 함수를 의미

<u>객체</u>.<u>메서드명</u><u>(인수)</u> 형태로 호출

```ts
const arr = [1, 10, 100];
arr.push(1000);
console.log(arr); // [1, 10, 100, 1000]라고 출력된다

// 여기는 컴파일 에러:
// Argument of type '"foobar"' is not assignable to parameter of type 'number'.
arr.push("foobar");
```

- push 메서드 : 배열의 끝에 요소를 추가하는 메서드
- arr은 number[ ] 타입이므로 arr.push에는 number 타입의 값을 넘길 수 있음
- `arr.push("foobar")`와 같이 호출하면 "foobar"가 number 타입이 아니기 때문에 에러

배열의 끝이 아닌 앞에 요소를 추가하는 unshift 메서드도 존재

```ts
const arr: readonly number[] = [1, 10, 100];
// 에러: Property 'push' does not exist on type 'readonly number[]'.
arr.push(1000);
```

- push나 unshift와 같은 메서드는 배열의 내용을 변경하는 메서드이므로 읽기 전용 배열 타입에 사용하면 에러

```ts
const arr = [1, 10, 100];
console.log(arr.includes(100)); // true라고 출력된다
console.log(arr.includes(50)); // false라고 출력된다

// 여기는 컴파일 에러:
// Argument of type '"foobar"' is not assignable to parameter of type 'number'.
console.log(arr.includes("foobar"));
```

- includes 메서드 : 배열이 주어진 값을 포함하는지를 불리언 값으로 반환하는 메서드
- 이 메서드는 배열을 변경하지 않으므로 읽기 전용 배열에서도 사용 가능

이 외에도 indexOf, slice, concat 등 다양한 메서드들이 많음 → MDN문서 참고

### 3.5.6 for-of 문 루프

for-of문 : 루프를 위해 만들어진 구문, 배열의 모든 요소를 순서대로 처리하는 데에 적합

for (const <u>변수</u> of <u>식</u>) 형태로 사용

배열의 요소가 앞에서부터 순서대로 변수에 들어감

```ts
const arr = [1, 10, 100];

for (const elm of arr) {
  console.log(elm);
}
```

- console.log가 3번 실행, 1, 10, 100 순으로 출력
- 변수 elm의 값이 루프마다 바뀌는데도 불구하고 변경 불가를 나타내는 const가 사용되는 것이 부자연스러울 수 있음
- 실제로는 각 루프에서 변수가 다시 만들어지기 때문에 const여도 문제가 없는 것
- 루프 안에서 변수에 재할당을 하고 싶다면 let을 사용해야 하지만, 그러한 경우는 거의 없음

```ts
const arr = [1, 10, 100];
for (let elm of arr) {
  elm *= 10;
  console.log(elm);
}
```

- 10, 100, 1000 출력, `elm *= 10`을 실행하기 위해서는 변수 elm을 let으로 선언해야 함
- elm을 변경해도 배열 arr에 영향이 가지 않음
  - 변수 elm은 arr의 각 요소가 매번 대입되는 변수일 뿐이며, arr의 내용 그 자체를 참조하는 것은 아니기 때문

### 3.5.7 튜플 타입

튜플 타입 : 요소의 개수가 고정된 배열 타입

요소의 수가 고정된 대신에 각 요소마다 서로 다른 타입을 넣을 수 있다는 특징을 가짐

number[ ] 같은 보통의 배열 타입은 요소가 몇 개여도 상관없는 대신, 모든 요소의 타입이 같음

튜플 타입의 구문은 [ ] 안에 타입을 콤마로 구분 지어 넣음

```ts
let tuple: [string, number] = ["foo", 0];
tuple = ["aiueo", -555];

const str = tuple[0]; // str은 string 타입
const num = tuple[1]; // num는 number 타입
// 에러: Tuple type '[string, number]' of length '2' has no element at index '2'.
const nothing = tuple[2];
```

- `[string, number]`는 요소가 두 개인 튜플 타입이고 0번째 요소가 string, 1번째 요소가 number 타입이라는 의미
- 요소의 개수를 넘는 위치에 접근하려 하면 에러

타입스크립트에서 튜플 타입은 배열 타입의 일종

- 자바스크립트가 튜플이라는 개념을 갖고 있지 않아서 배열을 대용으로 사용 (튜플은 배열처럼 여러 개의 데이터를 열거하여 담아두는 자료 구조)
- 따라서 튜플 타입의 값을 만들 때에는 배열 리터럴을 사용
- 튜플은 각 데이터마다 일일이 이름을 붙이지 않는다는 점이 객체 타입과 다름
- 튜플 타입 안의 데이터에 접근할 때는 배열처럼 0번째 데이터, 1번째 데이터와 같은 형태로 프로퍼티 접근을 함

```ts
type User = [name: string, age: number];

const uhyo: User = ["uhyo", 26];

console.log(uhyo[1]); // 26이라고 출력된다
```

- 라벨링된 튜플 타입 : 튜플 타입의 각 요소 앞에 <u>식별자</u>: 라는 구문을 추가할 수 있음
- 이렇게 하면 튜플 타입의 각 요소가 무엇을 나타내는지 이해하기 쉬움
  - 큰 의미는 없음
  - 라벨을 붙였어도 튜플의 요소를 `uhyo.name`과 같은 형태로 가져오거나 할 수 없고, 여전히 `uhyo[0]`과 같이 사용해야 함

읽기 전용 튜플 타입 : `readonly [string, number]`와 같이 사용, 요소를 변경할 수 없음

선택적 요소를 가지는 튜플 타입 : `[string, number, string?]`과 같이 사용, 맨 마지막의 string 타입 요소가 있든 없든 상관하지 않겠다는 의미

- 예를 들면 `["uhyo", 26]`처럼 요소가 두 개인 배열과 `["uhyo", 26, "hello"]`처럼 세 개인 배열을 모두 `[string, number, string?]` 타입으로 처리 가능  
  변수 tuple이 이 타입이라면 tuple[2] 타입은 `string | undefined`가 됨

### 배열 요소 접근의 비밀스러운 위험성

타입스크립트가 에러로 위험을 알려주지 못하는 경우 중 한가지, 배열의 인덱스 접근

배열은 arr[1]과 같이 원하는 위치의 요소에 접근할 수 있지만, 사실 존재하지 않는 위치의 요소에도 접근할 수 있음

타입스크립트에서는 존재하지 않는 프로퍼티에 접근하면 undefined를 얻게 되므로, 타입과 실제 값이 어긋나는 현상이 생길 수 있음

```ts
const arr = [1, 10, 100];
const num: number = arr[100];
console.log(num); // undefined라고 출력된다
```

- arr은 number[ ]타입 배열이고 arr[0]에서 arr[2]까지밖에 요소가 존재하지 않음
- 그럼에도 불구하고 위 코드에서는 arr[100]에 접근하고 있음
- 타입 정보상에서 number[ ]는 number 타입의 배열이므로 요소가 몇 개 있는지에 대한 정보는 존재하지 않음
  - 배열 타입은 요소가 몇 개 있는지를 타입상에서 알 수 없는(요소가 몇 개여도 상관하지 않는) 특징을 가진 타입이기 때문
  - 따라서 요소의 개수가 정해져 있다면 튜플 타입을 사용하는 것이 적합
- 컴파일 기본 옵션에서는 number[ ] 배열 타입의 몇 번째 요소에 접근해도 요소의 타입이 모두 number
- 따라서 arr[100]은 number 타입의 값으로 간주되므로 number 타입의 변수 num에 대입할 수 있음
- 하지만 런타임에서는 arr에 100번째 요소가 존재하지 않아서 arr[100]이 undefined가 되는 것
- 이때 number 타입 변수에 undefined가 들어가는 부정합이 발생
- 이러한 위험성을 피하는 방법 중 하나는 arr[100]과 같은 인덱스 접근을 최대한 쓰지 않는 것
- 배열의 요소를 사용할 때는 for-of문 등의 방법을 대신 사용하므로써 이러한 위험성을 회피
