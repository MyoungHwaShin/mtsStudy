# 8. 비동기 처리

- [8. 비동기 처리](#8-비동기-처리)
  - [8.1 비동기 처리란?](#81-비동기-처리란)
    - [8.1.1 "시간이 걸리는 처리"로서의 비동기 처리](#811-시간이-걸리는-처리로서의-비동기-처리)
    - [8.1.2 싱글 스레드 모델, 논블로킹](#812-싱글-스레드-모델-논블로킹)
  - [8.2 콜백에 의한 비동기 처리](#82-콜백에-의한-비동기-처리)
    - [8.2.1 콜백 함수란](#821-콜백-함수란)
    - [8.2.2 타이머 예시](#822-타이머-예시)
    - [8.2.3 fs 모듈에 의한 파일 처리 예시](#823-fs-모듈에-의한-파일-처리-예시)
    - [8.2.4 동기 처리와 비동기 처리의 순서](#824-동기-처리와-비동기-처리의-순서)

<br />

## 8.1 비동기 처리란?

무엇인지 정확하게 설명하기 어려우나

- **뒤에서 수행되는 처리**
- **시간이 걸리는 처리**

<br />

### 8.1.1 "시간이 걸리는 처리"로서의 비동기 처리

- **통신** (브라우저: 서버)
- **파일 입출력** (CPU: HDD나 SSD 접근)
- 애플리케이션 서버 만들 때 다른 서버의 처리를 기다려야 하는 경우(DB 접근) 등

<br />

### 8.1.2 싱글 스레드 모델, 논블로킹

타입스크립트에서의 시간이 걸리는 처리는 "비동기로 처리" <br />=> 즉, **논블로킹** 으로 처리된다.

<br />

🤔 **블로킹 처리**

- 해당 처리가 실행 완료될 때까지 프로그램이 그곳에서 정지(타임 로스)되는 처리

```ts
console.log("파일을 불러옵니다");
// 파일 입출력을 블로킹 처리로 수행하는 readFile 함수
const data = readFile("filename.txt");
console.log("완료됐습니다");
```

<br />

✅ 자바스크립트, 타입스크립트는 **싱글 스레드** 모델을 실행 모델로 채택하였기 때문에 시간이 걸리는 처리가 블로킹 처리되는 것을 반기지 않는다. <br />
😀 **프로그램 여러 곳에서 실행이 동시에(병렬로) 이뤄지는 일은 없다** == 실행은 항상 한 군데

<br />

✅ **예시: 웹 서버**

- 복수의 클라이언트가 동시에 접속해 오더라도 응대할 수 있어야한다.
- <u>싱글 스레드 + 통신 기능 블로킹</u> 이라면 한 클라이언트와 통신하는 동안 프로그램 실행이 멈추고 웹 서버 작동이 완전히 정지되어 <u>동시에 복수의 클라이언트를 응대할 수 없다.</u>
- <u>싱글 스레드 + 통신 기능 논블로킹</u> 이라면 프로그램이 정지하지 않아 <u>동시에 복수의 클라이언트를 응대할 수 있다.</u> => 성능 향상

🤔 **싱글 스레드인데도 통신 처리 실행 중 다른 일을 할 수 있는 이유?**

- 실제 통신을 담당하는 것이 Node.js 등의 런타임이 아닌 OS이기 때문이다.
- 자바스크립트로 만들어진 서버는 클라이언트 요청에 대한 응답을 계산하는 부분(애플리케이션 로직) 담당, OS는 클라이언트가 보낸 요청이나 응답의 실제 송수신 담당.
- **애플리케이션 로직이 들어간 자바스크립트 프로그램 부분이 병렬로 실행되지 않는다.**

<br />

## 8.2 콜백에 의한 비동기 처리

### 8.2.1 콜백 함수란

- **비동기 처리가 끝났을 때 호출되는 함수**
- 비동기 처리의 **실행을 시작** 하는 함수
- 프로그램은 실행을 시작하고 종료를 기다리지 않은 채 다음 부분으로 넘어가기 때문에, 비동기 처리의 실행 종료를 감지할 수단으로 사용(함수 호출)한다.

```ts
console.log("1. 파일을 불러옵니다");
// 인수로 전달된 콜백 함수
readFile("filename.txt", (data) => {
  console.log("3. 파일 불러오기 완료");
});
console.log("2. 파일 불러오기 시작");
```

<br />

### 8.2.2 타이머 예시

```ts
// 콜백 함수, 인수
setTimeout(() => {
  console.log("타이머가 호출됐습니다");
}, 3000);
console.log("타이머를 설정했습니다");
```

🤔 **`setTimeout` 실행 과정**

- 정의: '일정 시간 대기' -> 시간이 걸리는 처리이며, 이 처리를 **비동기적** 으로 수행해 주는 함수
- setTimeout 자체는 '일정 시간 대기'하는 처리를 시작할 뿐이고, 이 처리는 한순간에 끝나게 된다.
- 프로그램 실행이 맨 마지막까지 도달했으므로 일단 멈추나 비동기 처리가 남아있기 때문에 종료되지 않고 아무것도 하지 않는 상태로 계속 구동된다.
- 그리고 3초가 지나면 setTimeout에 의해 시작되었던 '3초 대기' 비동기 처리가 종료되며, 콜백 함수가 호출된다.
- 콜백 함수에서 "타이머가 호출됐습니다"를 출력한다.
- 프로그램은 여기서 또다시 맨 마지막에 도달하게 되고, 이번에는 콜백이 남아있지 않으므로 프로세스가 종료된다.

<br />

😀 함수 setTimeout에 의해 시작되는 **"일정 시간 대기" 비동기 처리에서는 콜백 함수 호출 형태로 처리 종료를 감지** 할 수 있다.

<br />

### 8.2.3 fs 모듈에 의한 파일 처리 예시

- 파일 시스템 접근은 시간이 걸리는 처리 => 비동기 처리
- 단, fs는 동기적인 API도 제공 (readFileSync 등)

```ts
import { readFile } from "fs";

// 콜백 함수에 의한 비동기 처리 API: 파일명, 입력 방식 지정, 콜백 함수
readFile("foo.txt", "utf8", (err, result) => {
  console.log(result);
});
console.log("불러오기 시작");
```

- err 인수: **에러** 발생 대응
- 파일 읽기 실패 시, 두 번째 인수 result가 null이 되는 대신, 첫 번째 인수 err로 에러를 나타내는 객체 전달
- 성공시, err가 null, result로 파일 읽기 결과 전달
- 비동기 함수에서 에러는 무시하기 쉽기 때문에 **에러 핸들링** 을 중요하게 생각해야 한다.

<br />

### 8.2.4 동기 처리와 비동기 처리의 순서

**동기적으로 실행 중인 프로그램에 비동기 처리가 끼어드는 일이 없다**

```ts
import { performance } from "perf_hooks";

// 비동기 처리
setTimeout(() => {
  console.log("타이머가 호출됐습니다");
}, 100);

// 동기 처리
const startTime = performance.now();
let count = 0;
while (performance.now() - startTime < 1000) {
  count++;
}
console.log(count);
```

=> 출력결과

```
71122412
타이머가 호출됐습니다
```

🤔 **count는 프로그램 실행이 시작된 지 1초 후에 출력되는데도 0.1초 타이머보다 먼저 출력이 될까?**

- 동기적으로 실행 중인 프로그램에 비동기 처리가 끼어드는 일은 없다.
- 즉, 함수 setTimeout을 호출한 뒤 while문으로 진입해서 그 처리가 종료된 후 `console.log(count)`가 실행되기까지의 흐름은 동기적인 실행! <br />=> `setTimeout -> const startTime ~~` 이라는 동기적인 실행. 그 밖의 코드가 실행되는 일 또한 없다.
- 따라서, **동기적인 실행 도중에 타이머가 종료됐다 하더라도 콜백 함수가 중간에 끼어들어서 실행되지 않는다.**
- 동기적인 실행이 완료되면 **더 이상 동기적으로 실행할 것이 남아있지 않아** 자유로운 상태가 되고, **이미 종료된 타이머의 콜백 함수로 차례가 돌아오면서 콜백 함수가 실행** 된다.

<br />

✅ 예시2: 파일 읽기(비동기 처리)가 아무리 빨리 끝나더라도 `readFile -> console.log`라는 동기적인 실행에 끼어들 수 없다.

```ts
import { readFile } from "fs";

readFile("foo.txt", "utf8", (err, result) => {
  console.log(result);
});
console.log("불러오기 시작");
```

=> 출력결과

```
불러오기 시작
result 결과값
```
