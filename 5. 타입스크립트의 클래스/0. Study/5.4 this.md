# 5. 타입스크립트의 클래스

- [5. 타입스크립트의 클래스](#5-타입스크립트의-클래스)
  - [5.4 this](#54-this)
    - [5.4.1 함수 안의 this는 호출 방법에 따라 정해진다](#541-함수-안의-this는-호출-방법에-따라-정해진다)
    - [5.4.2 화살표 함수에서의 this](#542-화살표-함수에서의-this)
    - [5.4.3 this를 조작하는 메서드](#543-this를-조작하는-메서드)
    - [5.4.4 함수 내부 이외의 this](#544-함수-내부-이외의-this)

## 5.4 this

자신을 가리킨다는 것 외의 `this` 지식을 쌓아보자!

### 5.4.1 함수 안의 this는 호출 방법에 따라 정해진다

`this` 는 기본적으로 자신을 나타내는 객체이며, 주로 메서드 안에서 사용된다.
함수 안의 `this`가 구체적으로 무엇을 가리키는지는 **함수의 호출 방법에 따라 결정**된다.

메서드는 객체의 프로퍼티에 들어있는 함수 객체이다.

```ts
uhyo.isAdult()

// 객체.메서드형 형태로 함수를 참조한다.
```

`.` 의 좌측에 있는 객체가 메서드 안에서의 `this`가 된다.
위 예시의 `this` 는 `uhyo`이므로 `uhyo.isAdult` 안에서 `this.age` 를 참조했다면 이는 `uhyo.age` 에 해당한다.

💁🏻‍♀ 객체의 메서드에서 `this` 를 사용하면, 그 메서드가 속해 있는 객체를 가리키는 것

`this` 는 동일한 클래스로부터 만들어진 복수의 인스턴스 객체들이 각자 독립적으로 자기 자신의 데이터를 참조할 수 있게 하기 위한 구조이다.

```ts
const uhyo = new User("uhyo", 26);
const john = new User("John Smith", 15);

// uhyo와 john이라는 두 객체가 동일한 isAdult 메서드를 가지고 있는지 확인해보기

console.log(uhyo.isAdult === john.isAdult);
// true가 출력된다
```

클래스가 같은 인스턴스가 여럿 존재할 경우 (`User`클래스의 인스턴스인 uhyo 와 john), 그 인스턴스들이 지닌 메서드는 동일한 함수 객체이다.

클래스 선언 안에 머스드를 정의하면 여러 인스턴스 간에 메서드의 함수 객체가 공유된다. 그러므로 클래스의 인스턴스를 여러 개 만들더라도 본문이 같은 함수 객체가 여러 개 양산되지 않아 경제적이다.

<br/>

`this` 의 내용물이 함수 호출 방법에 따라 정해진다는 것은 호출을 잘못하면 제대로 작동하지 않는다는 의미이기도 하다. 💁🏻‍♀ `this` 를 사용하는 함수를 메서드 호출 기법을 쓰지 않고 호출했을 때 문제가 된다.

```ts
class User {
  name: string;
  #age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.#age = age;
  }

  public isAdult(): boolean {
    return this.#age >= 20;
  }
}

const uhyo = new User("uhyo", 26);

const isAdult = uhyo.isAdult;
// 런타임 에러: attempted to get private field on non-instance
console.log(isAdult());

```

`uhyo.isAdult` 에 들어 있는 함수 객체를 변수 `isAdult`에 담은 뒤 호출했다. 따라서 해당 함수 객체는 `객체.isAdult()` 형태로 호출되지 않았따. 이렇게 메서드 기법을 쓰지 않고 함수를 호출했을 때, 그 안의 `this` 값은 `undefined` 가 된다.

함수 안에서 `this` 값이 `undefined` 가 될 뿐이라 매번 런타임 에러가 발생하는 것은 아니지만, `this` 의 용도 대부분은 프로퍼티 참조라서 런타임 에러가 발생하는 경우가 많을 것이다.

💁🏻‍♀ 여기서 `this` 를 사용하는 객체의 메서드는 원칙적으로 **메서드 기법을 통해 호출해야 한다**는 점을 알 수 있다.

<br/>

- 클래스를 사용하지 않고 `this` 사용하기
```ts
const user = {
  name: "uhyo",
  age: 26,
  isAdult() {
    return this.age >= 20;
  }
};

console.log(user.isAdult()); // true가 출력된다
user.age = 15;
console.log(user.isAdult()); // false가 출력된다
```

`user` 객체에 정의된 `isAdult` 메서드 안에서 `this` 를 사용하고 있다. 이 메서드는 `user.isAdult()` 형태로 호출되었기 때문에 메서드 안의 `this` 는 `user` 를 가리킨다.

🍭 이와 같이 함수 내에서 `this`의 값은 호출 방법에 따라 정해진다. 여기서 예외가 하나 있는데, 화살표 함수이다.

<br>

### 5.4.2 화살표 함수에서의 this

화살표 함수와 `this` 의 기능에 대해서 알아보도록 하자 !!!

화살표 함수에는 `this` 에 관한 특수한 성질이 있다. 바로 화살표 함수는 **`this` 를 바깥쪽이 함수에서 받아온다** 는 것이다.따라서 화살표 함수는 **자기 자신의 `this`를 갖지 않는다**라고 말할 수도 있다. 자기 자신의 `this`를 갖지 않기 때문에 화살표 함수 내의 `this` 가 그 바깥쪽 함수의 `this` 와 같아진다.

`User` 클래스에 `User` 의 배열을 받아 그 안에서 자신보다 나이가 많은 `User` 인스턴스만을 추출한 배열을 반환하는 `filterOlder` 메서드를 추가해보자,

```ts
class User {
  name: string;
  #age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.#age = age;
  }

  public isAdult(): boolean {
    return this.#age >= 20;
  }

  public filterOlder(users: readonly User[]): User[] {
    return users.filter(u => u.#age > this.#age);
  }
}

const uhyo = new User("uhyo", 25);
const john = new User("John Smith", 15);
const bob = new User("Bob", 40);

const older = uhyo.filterOlder([john, bob]);
// [ User { name: "Bob" } ]라고 출력된다
console.log(older);
```

`[jogn, bob]` 배열을 `uhyo.filterOlder`에 전달한 결과로 `bob`만 남은 배열을 얻었다.

- `this` 가 사용된 곳은 !?

`users.filter(u => u.#age > this.#age)` 식은 `users.filter` 를 호출할 때 콜백함수로 화살표 함수를 전달한다. 그리고 화살표 함수 안에서 `u.#age`와 `this.#age`를 비교하는데, 여기에서 `this`가 사용되었다.

이 `this` 는 `filterOlder` 메서드 안에서의 `this` 와 같다. 왜냐하면 화살표 함수 안의 `this` 는 바깥쪽 함수의 `this`를 이어받는데, 이번 경우에는 바깥쪽 함수가 `filterOlder` 이기 때문이다.

<details>
<summary>
이 메서드가 uhyo.filterOlder(...) 로 호출됐다면 메서드 안의 this 는 무엇이 될까?
</summary>
uhyo
</details>

<details>
<summary>
u => u.#age > this.#age 안의 this 는 무엇이 될까?
</summary>
uhyo
</details>

화살표 함수의 호출 방법은 화살표 함수 내의 `this` 에 영향을 미치지 않는다. 화살표 함수 내의 `this` 는 호출 방법에 상관없이 화살표 함수를 만든 곳을 통해 예측할 수 있다.

화살표 함수가 없으면 메서드 구현이 번거로워진다.
위 예시의 `filterOlder` 를 보통의 함수 표현식으로 구현할 경우, 컴파일 에러가 발생한다.

```ts
public filterOlder(users: User[]): User[] {
  // 에러: 'this' implicitly has type 'any' because it does not have a type annotation.
  return users.filter(function(u) {return u.#age > this.#age });
}
```

이 에러는 function 함수 표현식 내의 `this` 가 타입 불명이라고 알려주고 있다.
이유는 화살표 함수를 사용하지 않아 `this` 의 값이 호출 방법에 따라 결정되는데, 이 함수는 `user.filter` 에 콜백 함수로 전달되므로 호출 방법을 미리 알 수 없기 때문이다.

- 해결방법

`this` 의 타입 표기해주기

함수 내에서 `this` 가 무엇인지 명시하고 싶을 때, 인수 목록의 앞부분에 `this` 를 넣고 타입을 기입하는 특수한 기법을 사용한다.

```ts
public filterOlder(users: User[]): User[] {
  return users.filter(function(this: User, u) {return u.#age > this.#age });
}
```

이렇게 하면 컴파일 에러가 사라지고 잘 해결된 것처럼 보인다. 하지만 실행하면 런타임 에러가 발생해 기대한 결과를 얻을 수 없다.

`this` 의 타입을 선언했다 하더라고 실제로 그 함수를 호출하는 것은 `users.filter` 이며, 호출 방법을 알아서 바꿔주지 않기 때문이다.

또한 타입스크립트의 타입 검사는 `this` 에 관한 부분이 약하다보니 `this` 의 타입 지정이 무시된다.

=> 함수 내의 `this` 타입 선언 기능 권장하지 않음 !!!

<br>

- 또 다른 해결 방법

`filterOlder` 내의 `this` 를 참조하기 위해서는 `this` 를 다른 변수에 미리 보존해야한다. 보존에 사용할 변수명을 `_this` 로 사용하기로 하자.

```ts
public filterOlder(users: User[]): User[] {
  const _this = this;
  return users.filter(function(u) {return u.#age > _this.#age });
}
```

이렇게 작성하면 기대한대로 작동하지만, 바깥쪽 함수로부터 `this` 를 이어받는 성질을 지닌 화살표 함수가 도입됨에 따라, `this` 를 별도로 보존할 필요가 없어졌다.

따라서 함수를 만들 때에는 특별한 의도가 없다면 화살표 함수를 사용하게 되었다.



### 5.4.3 this를 조작하는 메서드

### 5.4.4 함수 내부 이외의 this
